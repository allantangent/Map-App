package com.example.deadl.apptest;import android.Manifest;import android.content.Intent;import android.content.IntentSender;import android.content.pm.PackageManager;import android.location.Location;import android.os.Bundle;import android.support.annotation.NonNull;import android.support.annotation.Nullable;import android.support.v4.app.ActivityCompat;import android.support.v4.app.FragmentActivity;import com.google.android.gms.common.ConnectionResult;import com.google.android.gms.common.api.GoogleApiClient;import com.google.android.gms.common.api.PendingResult;import com.google.android.gms.common.api.ResultCallback;import com.google.android.gms.common.api.Status;import com.google.android.gms.location.LocationAvailability;import com.google.android.gms.location.LocationListener;import com.google.android.gms.location.LocationRequest;import com.google.android.gms.location.LocationServices;import com.google.android.gms.location.LocationSettingsRequest;import com.google.android.gms.location.LocationSettingsResult;import com.google.android.gms.location.LocationSettingsStatusCodes;import com.google.android.gms.maps.CameraUpdateFactory;import com.google.android.gms.maps.GoogleMap;import com.google.android.gms.maps.OnMapReadyCallback;import com.google.android.gms.maps.SupportMapFragment;import com.google.android.gms.maps.model.LatLng;import com.google.android.gms.maps.model.Marker;import com.google.android.gms.maps.model.MarkerOptions;public class MapsActivity extends FragmentActivity implements OnMapReadyCallback, GoogleApiClient.ConnectionCallbacks,        GoogleApiClient.OnConnectionFailedListener, GoogleMap.OnMarkerClickListener, LocationListener{    private GoogleMap mMap;    private GoogleApiClient mGoogleApiClient; //need to create one to connect to play services library    private static final int LOCATION_PERMISSION_REQUEST_CODE = 1; //checks for permission to access location    private Location mLastLocation; //essentially current location    private LocationRequest mLocationRequest; //live location updates    private boolean mLocationUpdateState; //live location updates    private static final int REQUEST_CHECK_SETTINGS = 2;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_maps);        // Obtain the SupportMapFragment and get notified when the map is ready to be used.        SupportMapFragment mapFragment = (SupportMapFragment) getSupportFragmentManager()                .findFragmentById(R.id.map);        mapFragment.getMapAsync(this);        if( mGoogleApiClient == null )        {            mGoogleApiClient = new GoogleApiClient.Builder( this ).addConnectionCallbacks( this ).addOnConnectionFailedListener( this )                    .addApi( LocationServices.API ).build();        }        createLocationRequest();    }    /**     * Manipulates the map once available.     * This callback is triggered when the map is ready to be used.     * This is where we can add markers or lines, add listeners or move the camera. In this case,     * we just add a marker near Sydney, Australia.     * If Google Play services is not installed on the device, the user will be prompted to install     * it inside the SupportMapFragment. This method will only be triggered once the user has     * installed Google Play services and returned to the app.     */    @Override    public void onMapReady(GoogleMap googleMap) {        mMap = googleMap;        // adding markers        final LatLng chris = new LatLng( 33.696071,-117.81370500000003 );        final LatLng myHouse = new LatLng( 33.6825231, -117.80378009999998 );        final LatLng houseOfFade = new LatLng( 33.8656271, -118.08262059999998 );        mMap.addMarker( new MarkerOptions().position( chris ).title( "Chris House" ) );        mMap.addMarker( new MarkerOptions().position( myHouse ).title( "My House" ) );        mMap.addMarker( new MarkerOptions().position( new LatLng( 33.678949, -117.80697700000002 ) ).title( "Woodbridge HS" ) ); //fast add        mMap.addMarker( new MarkerOptions().position( new LatLng( 33.691799, -117.76764500000002 ) ).title( "HS2 Academy" ) );        mMap.addMarker( new MarkerOptions().position( houseOfFade ).title( "House of Fade" ).snippet( "Appointment Only" ) );        //mMap.moveCamera(CameraUpdateFactory.newLatLng(sydney)); this is how to center something on a marker        mMap.getUiSettings().setZoomControlsEnabled( true );        mMap.setOnMarkerClickListener( this );    }    @Override    public void onLocationChanged(Location location) {    }    @Override    public void onConnected(@Nullable Bundle bundle) {        setUpMap();        if( mLocationUpdateState )            startLocationUpdates();    }    @Override    public void onConnectionSuspended(int i) {    }    @Override    public void onConnectionFailed(@NonNull ConnectionResult connectionResult) {    }    @Override    public boolean onMarkerClick(Marker marker) {        return false;    }    @Override    protected void onStart()    {        super.onStart();        mGoogleApiClient.connect();    }    @Override    protected void onStop()    {        super.onStop();        if( mGoogleApiClient != null && mGoogleApiClient.isConnected() )            mGoogleApiClient.disconnect();    }    //initiating map layer and setting its functions    private void setUpMap()    {        mMap.setMapType( GoogleMap.MAP_TYPE_HYBRID );        if( ActivityCompat.checkSelfPermission( this, Manifest.permission.ACCESS_FINE_LOCATION ) != PackageManager.PERMISSION_GRANTED ) {            ActivityCompat.requestPermissions( this, new String[]{ Manifest.permission.ACCESS_FINE_LOCATION }, LOCATION_PERMISSION_REQUEST_CODE );            return;        }        mMap.setMyLocationEnabled( true );        LocationAvailability locationAvailability = LocationServices.FusedLocationApi.getLocationAvailability( mGoogleApiClient );        if( null != locationAvailability && locationAvailability.isLocationAvailable() )            mLastLocation = LocationServices.FusedLocationApi.getLastLocation( mGoogleApiClient );        if( mLastLocation != null )        {            LatLng currentLocation = new LatLng( mLastLocation.getLatitude(), mLastLocation.getLongitude() );            mMap.animateCamera( CameraUpdateFactory.newLatLngZoom( currentLocation, 17 ) );        }    }    protected void startLocationUpdates()    {        if( ActivityCompat.checkSelfPermission( this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED )        {            ActivityCompat.requestPermissions( this, new String [] { Manifest.permission.ACCESS_FINE_LOCATION}, LOCATION_PERMISSION_REQUEST_CODE );            return;        }        LocationServices.FusedLocationApi.requestLocationUpdates( mGoogleApiClient, mLocationRequest, this );    }    protected void createLocationRequest()    {        mLocationRequest = new LocationRequest();        mLocationRequest.setInterval( 10000 );        mLocationRequest.setFastestInterval( 5000 );        mLocationRequest.setPriority( LocationRequest.PRIORITY_HIGH_ACCURACY );        LocationSettingsRequest.Builder builder = new LocationSettingsRequest.Builder().addLocationRequest( mLocationRequest );        PendingResult< LocationSettingsResult> result = LocationServices.SettingsApi.checkLocationSettings( mGoogleApiClient, builder.build() );        result.setResultCallback( new ResultCallback< LocationSettingsResult >() {            @Override            public void onResult( @NonNull LocationSettingsResult result )            {                final Status status = result.getStatus();                switch( status.getStatusCode() )                {                    case LocationSettingsStatusCodes.SUCCESS:                        mLocationUpdateState = true;                        startLocationUpdates();                        break;                    case LocationSettingsStatusCodes.RESOLUTION_REQUIRED:                        try                        {                            status.startResolutionForResult( MapsActivity.this, REQUEST_CHECK_SETTINGS );                        }catch( IntentSender.SendIntentException e )                        {                        }                        break;                    case LocationSettingsStatusCodes.SETTINGS_CHANGE_UNAVAILABLE:                        break;                }            }        } );    }    @Override    protected void onActivityResult( int requestCode, int resultCode, Intent data )    {        super.onActivityResult( requestCode, resultCode, data );        if( requestCode == REQUEST_CHECK_SETTINGS )        {            if( resultCode == RESULT_OK )            {                mLocationUpdateState = true;                startLocationUpdates();            }        }    }    @Override    protected void onPause()    {        super.onPause();        LocationServices.FusedLocationApi.removeLocationUpdates( mGoogleApiClient, this );    }    @Override    public void onResume()    {        super.onResume();        if( mGoogleApiClient.isConnected() && !mLocationUpdateState )            startLocationUpdates();    }    protected void placeMarkerOnMap( LatLng location )    {        MarkerOptions markerOptions = new MarkerOptions().position( location );        mMap.addMarker( markerOptions );    }}